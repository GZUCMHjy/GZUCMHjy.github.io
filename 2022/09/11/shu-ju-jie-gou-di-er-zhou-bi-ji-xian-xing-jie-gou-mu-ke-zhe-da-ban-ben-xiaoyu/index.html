<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>数据结构笔记(一) | 向阳而生_预见未来</title><meta name="keywords" content="数据结构"><meta name="author" content="louisBrilliant"><meta name="copyright" content="louisBrilliant"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="数据结构第二周笔记——线性结构(慕课浙大版本–XiaoYu)2.1.1 引子：多项式表示例子：一元多项式及其运算  主要运算：多项式相加、相减、相乘等 分析–如何表示多项式 多项式的关键数据：  多项式项数n  各项系数ai以及指数i(这里的ai的i是指a的下标) 方法1：顺序存储结构直接表示   注解：其实这个的意思就是从头加到尾，不管中间的答案有没有像0这种可以直接省略掉的值都会占一个位置。">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构笔记(一)">
<meta property="og:url" content="http://gzucmhjy.github.io/2022/09/11/shu-ju-jie-gou-di-er-zhou-bi-ji-xian-xing-jie-gou-mu-ke-zhe-da-ban-ben-xiaoyu/index.html">
<meta property="og:site_name" content="向阳而生_预见未来">
<meta property="og:description" content="数据结构第二周笔记——线性结构(慕课浙大版本–XiaoYu)2.1.1 引子：多项式表示例子：一元多项式及其运算  主要运算：多项式相加、相减、相乘等 分析–如何表示多项式 多项式的关键数据：  多项式项数n  各项系数ai以及指数i(这里的ai的i是指a的下标) 方法1：顺序存储结构直接表示   注解：其实这个的意思就是从头加到尾，不管中间的答案有没有像0这种可以直接省略掉的值都会占一个位置。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://gzucmhjy.github.io/img/landscape_sky3.webp">
<meta property="article:published_time" content="2022-09-11T15:30:34.026Z">
<meta property="article:modified_time" content="2022-09-11T15:40:08.073Z">
<meta property="article:author" content="louisBrilliant">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://gzucmhjy.github.io/img/landscape_sky3.webp"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://gzucmhjy.github.io/2022/09/11/shu-ju-jie-gou-di-er-zhou-bi-ji-xian-xing-jie-gou-mu-ke-zhe-da-ban-ben-xiaoyu/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"prismjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数据结构笔记(一)',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-09-11 23:40:08'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="向阳而生_预见未来" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fpic1.win4000.com%2Fwallpaper%2F4%2F584688f74cfbc.jpg%3Fdown&amp;refer=http%3A%2F%2Fpic1.win4000.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1662903731&amp;t=d4ee1314a1f8bbd979b30bd14eda9c5c" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/./img/landscape_sky3.webp')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">向阳而生_预见未来</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">数据结构笔记(一)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-09-11T15:30:34.026Z" title="发表于 2022-09-11 23:30:34">2022-09-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-09-11T15:40:08.073Z" title="更新于 2022-09-11 23:40:08">2022-09-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">11.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>39分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="数据结构笔记(一)"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="数据结构第二周笔记——线性结构-慕课浙大版本–XiaoYu"><a href="#数据结构第二周笔记——线性结构-慕课浙大版本–XiaoYu" class="headerlink" title="数据结构第二周笔记——线性结构(慕课浙大版本–XiaoYu)"></a>数据结构第二周笔记——线性结构(慕课浙大版本–XiaoYu)</h1><h3 id="2-1-1-引子：多项式表示"><a href="#2-1-1-引子：多项式表示" class="headerlink" title="2.1.1 引子：多项式表示"></a>2.1.1 引子：多项式表示</h3><h4 id="例子：一元多项式及其运算"><a href="#例子：一元多项式及其运算" class="headerlink" title="例子：一元多项式及其运算"></a>例子：一元多项式及其运算</h4><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/925/image-20220627134344443.png" alt="image-20220627134344443" style="zoom:50%;">

<p>主要运算：多项式相加、相减、相乘等</p>
<p><strong>分析</strong>–<strong>如何表示多项式</strong></p>
<p>多项式的关键数据：</p>
<ol>
<li><p>多项式项数n</p>
</li>
<li><p>各项系数ai以及指数i(这里的ai的i是指a的下标)</p>
<p><strong>方法1</strong>：顺序存储结构直接表示</p>
<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/925/image-20220627134953388.png" alt="image-20220627134953388" style="zoom:50%;"></li>
</ol>
<p>注解：其实这个的意思就是从头加到尾，不管中间的答案有没有像0这种可以直接省略掉的值都会占一个位置。</p>
<p>所以上方那个问题中如何表示多项式的答案是：需要占2001个位置，首选他是顺序存储结构，然后下标从0开始，所以是2001而不是2000</p>
<p><strong>方法2</strong>：顺序存储结构表示非零项(按照指数大小有序存储，比如说指数大的排在前面，指数小的排在后面)</p>
<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/925/image-20220627140021075.png" alt="image-20220627140021075" style="zoom:50%;">

<p>多项式相加过程：从头开始，比较两个多项式当前对应项的的指数  =&gt;这样就能够做到指数递降运算</p>
<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/925/image-20220627140719716.png" alt="image-20220627140719716" style="zoom:50%;">

<p>这里的(11，8)是(15，8)与(-4，8)的结合结果，因为指数一样，所以可以结合为一个</p>
<p>这种方法可以有效节省空间，操作效率也不算差</p>
<p><strong>方法3</strong>：链表结构存储非零项</p>
<ol>
<li>链表中每个节点存储多项式中的一个非零项，包括系数和指数两个数据域以及一个指针域</li>
<li>coef：指数  expon：系数  link：指针域</li>
<li>用指针域将不同的项串起来，同样可以做到指数递降的顺序进行排序</li>
</ol>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//代码演示</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">PolyNode</span><span class="token operator">*</span>Polynomial<span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">PolyNode</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> coef<span class="token punctuation">;</span>
    <span class="token keyword">int</span> expon<span class="token punctuation">;</span>
    Polynomial link<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/925/image-20220627141534773.png" alt="image-20220627141534773" style="zoom:50%;">

<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/925/image-20220627141555193.png" alt="image-20220627141555193" style="zoom:50%;">

<p>分别指向多项式的头，然后比较指数大小，大的输出；相等的话，系数相加</p>
<h3 id="2-1-2-线性表及顺序存储"><a href="#2-1-2-线性表及顺序存储" class="headerlink" title="2.1.2 线性表及顺序存储"></a>2.1.2 线性表及顺序存储</h3><p><strong>什么是线性表</strong>:由同类型数据元素构成有序列表的线性结构</p>
<ol>
<li>表中元素个数称为线性表的长度</li>
<li>线性表没有元素的时候，称为空表</li>
<li>表起始位置称表头，表结束位置称表尾</li>
</ol>
<p>多项式表示问题的启示：</p>
<ol>
<li>同一个问题可以有不同的表示(存储)方法  =&gt;通常来说的话是使用链表或者数组来进行存储</li>
<li>有一类共性问题：有序线性序列的组织和管理</li>
</ol>
<p><strong>线性表的抽象数据类型描述</strong></p>
<p>类型名称：线性表(List)</p>
<p>数据对象集：线性表是n(&gt;=0)个元素构成的有序列表(a1,a2,…,an)</p>
<p>操作集：线性表L属于List，整数i表示位置，元素X属于ElementType(这个类型可以是整型也可以是实型又或者是个结构，这里统称ElementType)</p>
<ol>
<li>List MakeEmpty()：初始化一个空线性表L</li>
<li>ElementType FindKth(int K,ListL)：根据位序K，返回相应元素;</li>
<li>int Find(ElementType X,int i, List L)：在线性表L中查找X的第一次出现位置;</li>
<li>void Insert(ElementType X,int i,List L)：在位序i前插入一个新元素X;</li>
<li>void Delete(int i,List L)：删除指定位序i的元素;</li>
<li>int Length(List L)：返回线性表L的长度n</li>
</ol>
<h4 id="线性表的顺序存储实现"><a href="#线性表的顺序存储实现" class="headerlink" title="线性表的顺序存储实现"></a>线性表的顺序存储实现</h4><p>利用数组的连续存储空间顺序存放线性表的各元素</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">LNode</span><span class="token operator">*</span>List<span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">LNode</span><span class="token punctuation">{</span>
    ElementType Data <span class="token punctuation">[</span>MAXSIZE<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//定义了一个数组，数组的分类类型是ElementType</span>
    <span class="token keyword">int</span> List<span class="token punctuation">;</span><span class="token comment">//代表线性表的最后一个元素，这样的一个结构就可以抽象的实现一个线性表</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">LNode</span> L<span class="token punctuation">;</span><span class="token comment">//定义一个变量L</span>
List PtrL<span class="token punctuation">;</span><span class="token comment">//还有一个变量PtrL</span>
	<span class="token comment">//访问下标为i的元素：L.Data[i]或PtrL-&gt;Data[i]</span>
	<span class="token comment">//线性表的长度：L.Last+1或PtrL-&gt;Last+1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/925/image-20220627191654197.png" alt="image-20220627191654197" style="zoom:50%;">

<p>“-&gt;”是一个整体，它是用于指向[结构体]子数据的指针，用来取子数据。</p>
<p>换种说法，如果我们在C语言中定义了一个结构体，然后申明一个指针指向这个结构体，那么我们要用指针取出结构体中的数据，就要用到“-&gt;”。</p>
<p><strong>主要操作的实现</strong></p>
<ol>
<li><p>初始化MakeEmpty(建立空的顺序表)</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">List <span class="token function">MakeEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	List PtrL<span class="token punctuation">;</span>
	PtrL <span class="token operator">=</span> <span class="token punctuation">(</span>List<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">LNode</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//通过malloc申请这样子一个结构</span>
	PtrL<span class="token operator">-&gt;</span>Last <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//Last设置为-1，因为Last是代表最后一个元素。Last为0是代表这个表有一个元素放在第一个位置，没元素就设置为-1，然后把这个结构的指针返还回来</span>
	<span class="token keyword">return</span> PtrL<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>查找</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//科普小知识</span>
find函数用于查找数组中的某一个指定元素的位置。

比如：有一个数组<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span>；
问：元素<span class="token number">5</span>的在什么位置，find函数 返回值 为 <span class="token number">2</span>；

find （数组名 <span class="token operator">+</span> 起始查找元素的位置， 数组名 <span class="token operator">+</span> 结束查找的元素位置， 想要查找的元素）

<span class="token keyword">int</span> <span class="token function">Find</span><span class="token punctuation">(</span>ElementType X<span class="token punctuation">,</span> List PtrL<span class="token punctuation">)</span><span class="token comment">//List PtrL是线性表结构的指针</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> PtrL <span class="token operator">-&gt;</span>Last <span class="token operator">&amp;&amp;</span> PtrL<span class="token operator">-&gt;</span>Data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!</span> <span class="token operator">=</span> X <span class="token punctuation">)</span>
        i<span class="token operator">++</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">&gt;</span> PtrL<span class="token operator">-&gt;</span>Last<span class="token punctuation">)</span>  <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//如果没找到，返回-1</span>
    <span class="token keyword">else</span> <span class="token keyword">return</span> i<span class="token punctuation">;</span><span class="token comment">//找到后返回的是存储位置</span>
<span class="token punctuation">}</span>
查找成功的平均比较次数为<span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">,</span>平均时间性能为<span class="token function">O</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="2-1-3顺序存储的插入和删除"><a href="#2-1-3顺序存储的插入和删除" class="headerlink" title="2.1.3顺序存储的插入和删除"></a>2.1.3顺序存储的插入和删除</h3><p>插入(第i(1&lt;=i&lt;=n+1)个位置上插入一个值为X的新元素)   其实就是决定什么时候插入线性表</p>
</li>
<li><p>下标是从0开始的，所以新插入的元素X放到i-1这个位置的话，首先需要把i-1之后的元素往后挪一位给i-1留出位置</p>
</li>
<li><p>也就是先移动再插入，每个元素往后挪使用一个循环就可以解决了</p>
</li>
<li><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/925/image-20220627200204195.png" alt="image-20220627200204195" style="zoom:50%;">
</li>
<li><p>从后往前算(挪)，如果从前往后的话算法是不对的</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//插入操作实现</span>
<span class="token keyword">void</span> <span class="token function">Insert</span><span class="token punctuation">(</span>ElementType X<span class="token punctuation">,</span><span class="token keyword">int</span> i<span class="token punctuation">,</span>List PtrL<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> j<span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>PtrL<span class="token operator">-&gt;</span>Last <span class="token operator">==</span> MAXSIZE<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//表空间已满，不能插入</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"表满"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">1</span> <span class="token operator">||</span> i <span class="token operator">&gt;</span> PtrL <span class="token operator">-&gt;</span> Last <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//检查插入的位置的合法性。超出这个范围就不行噢</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"位置不合法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>j <span class="token operator">=</span> PtrL<span class="token operator">-&gt;</span>Last<span class="token punctuation">;</span> j<span class="token operator">&gt;=</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">--</span><span class="token punctuation">)</span><span class="token comment">//List是最后一个元素的位置</span>
        PtrL<span class="token operator">-&gt;</span>Data<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> PtrL<span class="token operator">-&gt;</span>Data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//将a1~an倒序向后移动</span>
    PtrL<span class="token operator">-&gt;</span>Data<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> X<span class="token punctuation">;</span><span class="token comment">//新元素插入</span>
    PtrL<span class="token operator">-&gt;</span>Last<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment">//Last仍指向最后元素</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//平均移动次数为n/2，平均时间性能为O(n)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c" data-language="c"><code class="language-c">
接下来我们来介绍一下另外一个操作：删除


如果把后移数组元素的循环

   <span class="token keyword">for</span> <span class="token punctuation">(</span> j <span class="token operator">=</span> PtrL<span class="token operator">-&gt;</span>Last<span class="token punctuation">;</span> j <span class="token operator">&gt;=</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">--</span> <span class="token punctuation">)</span>

       PtrL<span class="token operator">-&gt;</span>Data<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>PtrL<span class="token operator">-&gt;</span>Data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>

改为

   <span class="token keyword">for</span> <span class="token punctuation">(</span> j <span class="token operator">=</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> PtrL<span class="token operator">-&gt;</span>Last<span class="token punctuation">;</span> j<span class="token operator">++</span> <span class="token punctuation">)</span>

       PtrL<span class="token operator">-&gt;</span>Data<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>PtrL<span class="token operator">-&gt;</span>Data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>

那会是什么后果？
    
分量Data<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>到Data<span class="token punctuation">[</span>Ptrl<span class="token operator">-&gt;</span>Last<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span>都是同一个值，即移之前Data<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>的值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>删除(删除表中的第i(1 &lt;= i &lt;= n)个位置上的元素)</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//删除掉这个元素后就空出来一个位置了，这种时候就需要从左往右的顺序往前挪</span>
<span class="token comment">//删除操作实现</span>
<span class="token keyword">void</span> <span class="token function">Detele</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span>List PtrL<span class="token punctuation">)</span><span class="token comment">//已知PtrL这个线性表</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> j<span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span> i <span class="token operator">&lt;</span> <span class="token number">1</span> <span class="token operator">||</span> i <span class="token operator">&gt;</span> PtrL<span class="token operator">-&gt;</span>Last<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"不存在第%d个元素"</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>j <span class="token operator">=</span> i<span class="token punctuation">;</span>j <span class="token operator">&lt;=</span> PtrL<span class="token operator">-&gt;</span>Last<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>
        PtrL<span class="token operator">-&gt;</span>Data<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> PtrL<span class="token operator">-&gt;</span>Data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//将a的下标(i+1)~an顺序往前移动</span>
    PtrL<span class="token operator">-&gt;</span>Last<span class="token operator">--</span><span class="token punctuation">;</span><span class="token comment">//Last仍指向最后元素</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//平均移动次数为(n-1)/2,平均时间性能为O(n)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
<h3 id="2-1-4-链式存储及查找"><a href="#2-1-4-链式存储及查找" class="headerlink" title="2.1.4 链式存储及查找"></a>2.1.4 链式存储及查找</h3><h4 id="线性表的链式存储实现"><a href="#线性表的链式存储实现" class="headerlink" title="线性表的链式存储实现"></a><strong>线性表的链式存储实现</strong></h4><ol>
<li><strong>不要求逻辑上相邻的两个元素物理上也相邻</strong>;通过”链”建立起数据元素之间的逻辑关系<ol>
<li>插入、删除不需要移动数据元素，只需要修改”链”</li>
</ol>
</li>
</ol>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">LNode</span> <span class="token operator">*</span>List<span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">LNode</span><span class="token punctuation">{</span>
    ElementType Data<span class="token punctuation">;</span>
    List Next<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">Lnode</span> L<span class="token punctuation">;</span>
List PtrL<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/925/image-20220627234839331.png" alt="image-20220627234839331" style="zoom:50%;">

<p><strong>主要操作的实现</strong></p>
<ol>
<li><p>求表长</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">Length</span><span class="token punctuation">(</span>List PtrL<span class="token punctuation">)</span><span class="token comment">//链表的头指针，并且是单向链表</span>
<span class="token punctuation">{</span>
    List p <span class="token operator">=</span> PtrL<span class="token punctuation">;</span><span class="token comment">//p指向表的第一个结点</span>
    <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">{</span>
        p <span class="token operator">=</span> p<span class="token operator">-&gt;</span>Next<span class="token punctuation">;</span><span class="token comment">//这步操作相当于让指针往后挪一位</span>
        j<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment">//当前p指向的是第j个结点</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> j<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//时间性能为O(n)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>查找</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//(1)按序号查找：FindKth;采用类似链表的遍历方法</span>
List <span class="token function">FindKth</span><span class="token punctuation">(</span><span class="token keyword">int</span> K<span class="token punctuation">,</span>List PtrL<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    List p <span class="token operator">=</span> PtrL<span class="token punctuation">;</span><span class="token comment">//首先把p这个临时变量设置为链表的表头</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;</span> K<span class="token punctuation">)</span><span class="token punctuation">{</span>
        p <span class="token operator">=</span> p<span class="token operator">-&gt;</span>Next<span class="token punctuation">;</span><span class="token comment">//让指针往后挪一位</span>
        i<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span> i <span class="token operator">==</span> K <span class="token punctuation">)</span> <span class="token keyword">return</span> p<span class="token punctuation">;</span><span class="token comment">//找到第K个，返回指针</span>
    <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token comment">//否则返回空</span>
<span class="token punctuation">}</span>
<span class="token comment">//(2)按值查找：Find</span>
List <span class="token function">Find</span><span class="token punctuation">(</span>ElementType X<span class="token punctuation">,</span>List PtrL<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    List p <span class="token operator">=</span> PtrL<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> p <span class="token operator">-&gt;</span> Data <span class="token operator">!=</span> X<span class="token punctuation">)</span>
        p <span class="token operator">=</span> p<span class="token operator">-&gt;</span>Next<span class="token punctuation">;</span>
    <span class="token keyword">return</span> p<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//返回的是两种结果，不是p就是NULL，调用Find函数，发现它返回值等于NULL，就说明没找着</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="2-1-5链式存储的插入和删除"><a href="#2-1-5链式存储的插入和删除" class="headerlink" title="2.1.5链式存储的插入和删除"></a>2.1.5链式存储的插入和删除</h3></li>
<li><p>插入(在第i-1(1 &lt;=  i &lt;= n+1)个结点后插入一个值为X的新结点)</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//(1)先构造一个新结点，用s指向;  这个时候可以用malloc这个函数来申请一块空间</span>
<span class="token comment">//(2)再找到链表的第i-1个结点，用p指向;</span>
<span class="token comment">//(3)然后修改指针，插入结点(p之后插入新结点是s)</span>


<span class="token comment">//下图中的操作步骤：让s指向下一个结点，p的Next附给s的Next</span>
<span class="token comment">//如果修改指针的两个步骤交换了一下哎，会发生什么？(语句执行顺序为：(1) p-&gt;Next=s;  (2) s-&gt;Next=p-&gt;Next;)</span>
<span class="token comment">//答案：s-&gt;Next指向s,从而不能正确完成插入</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/925/image-20220628002106165.png" alt="image-20220628002106165" style="zoom:50%;">

<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//malloc复习区域</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;malloc.h&gt;</span><span class="token expression">或者#include<span class="token operator">&lt;</span>alloc<span class="token punctuation">.</span>h<span class="token operator">&gt;</span></span><span class="token comment">//两者的内容是完全一样的</span></span>
如果分配成功：则返回指向被分配内存空间的指针
不然返回指针<span class="token constant">NULL</span>
同时，当内存不再使用的时候，应使用<span class="token function">free</span><span class="token punctuation">(</span><span class="token punctuation">)</span>函数将内存块释放掉。
关于：<span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">,</span>表示未确定类型的指针，c<span class="token punctuation">,</span>c<span class="token operator">++</span>规定<span class="token keyword">void</span><span class="token operator">*</span>可以强转为任何其他类型的指针，关于<span class="token keyword">void</span>还有一种说法就是其他任何类型都可以直接赋值给它，无需进行强转，但是反过来不可以
malloc<span class="token operator">:</span>
malloc分配的内存大小至少为参数所指定的字节数
malloc的返回值是一个指针，指向一段可用内存的起始位置，指向一段可用内存的起始地址，多次调用malloc所分配的地址不能有重叠部分，除非某次malloc所分配的地址被释放掉malloc应该尽快完成内存分配并返回（不能使用NP<span class="token operator">-</span>hard的内存分配算法）实现malloc时应同时实现内存大小调整和内存释放函数（realloc和free）
malloc和free是配对的，如果申请后不释放就是内存泄露，如果无故释放那就是什么也没做，释放只能释放一次，如果一块空间释放两次或者两次以上会出现错误（但是释放空指针例外，释放空指针也等于什么也没做，所以释放多少次都是可以的。）
<span class="token number">2</span>、malloc和new
new返回指定类型的指针，并且可以自动计算所需要的大小。
    <span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>
p <span class="token operator">=</span> new <span class="token keyword">int</span><span class="token punctuation">;</span><span class="token comment">//返回类型为int* ，分配的大小是sizeof(int)</span>
p <span class="token operator">=</span> new <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//返回类型是int*类型，分配的大小为sizeof(int)*100</span>

而malloc需要我们自己计算字节数，并且返回的时候要强转成指定类型的指针。
    <span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>
p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">1</span>）malloc的返回是<span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">,</span>如果我们写成了：p<span class="token operator">=</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>间接的说明了（将<span class="token keyword">void</span>转化给了<span class="token keyword">int</span><span class="token operator">*</span>，这不合理）
（<span class="token number">2</span>）malloc的实参是<span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>，用于指明一个整型数据需要的大小，如果我们写成p<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>那么可以看出：只是申请了一个一个字节大小的空间。
（<span class="token number">3</span>）malloc只管分配内存，并不能对其进行初始化，所以得到的一片新内存中，其值将是随机的。一般意义上：我们习惯性的将其初始化为<span class="token constant">NULL</span>，当然也可以使用memset函数。
简单的说：
malloc函数其实就是在内存中找一片指定大小的空间，然后将这个空间的首地址给一个指针变量，这里的指针变量可以是一个单独的指针，也可以是一个数组的首地址，这要看malloc函数中参数size的具体内容。我们这里malloc分配的内存空间在逻辑上是连续的，而在物理上可以不连续。我们作为程序员，关注的是逻辑上的连续，其他的操作系统会帮着我们处理。
下面就来看看malloc具体是怎么实现的。
首先要了解操作系统相关的知识：
虚拟内存地址和物理内存地址
为了简单，现代操作系统在处理物理内存地址时，普遍采用虚拟内存地址技术。即在汇编程序层面，当涉及内存地址时，都是使用的虚拟内存地址。采用这种技术时，每个进程仿佛自己独享一片<span class="token number">2</span>N字节的内存，其中N是机器位数。例如在<span class="token number">64</span>位CPU和<span class="token number">64</span>位操作系统下每个进程的虚拟地址空间为<span class="token number">264</span>Byte。
这种虚拟地址空间的作用主要是简化程序的编写及方便操作系统对进程间内存的隔离管理，真实中的进程不太可能如此大的空间，实际能用到的空间大小取决于物理内存的大小。
由于在机器语言层面都是采用虚拟地址，当实际的机器码程序涉及到内存操作时，需要根据当前进程运行的实际上下文将虚拟地址转化为物理内存地址，才能实现对内存数据的操作。这个转换一般由一个叫MMU的硬件完成。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>插入实现操作</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">List <span class="token function">Insert</span><span class="token punctuation">(</span>ElementType X<span class="token punctuation">,</span><span class="token keyword">int</span> i<span class="token punctuation">,</span>List PtrL<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    List p<span class="token punctuation">,</span>s<span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//新结点插入在表头</span>
        s <span class="token operator">=</span> <span class="token punctuation">(</span>List<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">LNode</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//申请、填装结点</span>
        s <span class="token operator">-&gt;</span> Data <span class="token operator">=</span> X<span class="token punctuation">;</span>
        s <span class="token operator">-&gt;</span> Next <span class="token operator">=</span> PtrL<span class="token punctuation">;</span>
        <span class="token keyword">return</span> s<span class="token punctuation">;</span><span class="token comment">//返回新表头指针</span>
    <span class="token punctuation">}</span>
    p <span class="token operator">=</span> <span class="token function">FindKth</span><span class="token punctuation">(</span>i<span class="token operator">-</span><span class="token number">1.</span>PtrL<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//查找第i-1个结点</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span> p <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//第i-1个不存在，不能插入</span>
    	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"参数i错"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
        s <span class="token operator">=</span> <span class="token punctuation">(</span>List<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">LNode</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//申请、填装结点</span>
        s <span class="token operator">-&gt;</span> Data <span class="token operator">=</span> X<span class="token punctuation">;</span>
        s <span class="token operator">-&gt;</span> Next <span class="token operator">=</span> p <span class="token operator">-&gt;</span> Next<span class="token punctuation">;</span><span class="token comment">//新结点插入在第i-1个结点的后面</span>
        p <span class="token operator">-&gt;</span> Next <span class="token operator">=</span> s<span class="token punctuation">;</span>
        <span class="token keyword">return</span> PtrL<span class="token punctuation">;</span> <span class="token comment">//这种情况下链表的头指针是不会变的</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">//平均查找次数是n/2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>删除(删除链表的第i(1 &lt;=  i  &lt;= n)个位置上的结点)</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//(1)先找到链表的第i-1个结点，用p指向;</span>
<span class="token comment">//(2)再用指针s指向要被删除的结点(p的下一个结点);</span>
<span class="token comment">//(3)然后修改指针，删除s所指结点;</span>
<span class="token comment">//(4)删除的结点(s)的空间要记得free释放掉(重要)，这样内存空间才不会泄漏</span>
List <span class="token function">Delete</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span>List PtrL<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    List p<span class="token punctuation">,</span>s<span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span> i <span class="token operator">==</span> <span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//若要删除的是表的第一个结点</span>
        s <span class="token operator">=</span> PtrL<span class="token punctuation">;</span><span class="token comment">//s指向第一个结点</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>PtrL <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> PtrL <span class="token operator">=</span> PtrL <span class="token operator">-&gt;</span> Next<span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
        <span class="token function">free</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//释放掉被删除结点</span>
        <span class="token keyword">return</span> PtrL<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    p <span class="token operator">=</span> <span class="token function">FindKth</span><span class="token punctuation">(</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>PtrL<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//查找第i-1个结点，就是要删除结点的前一个结点在哪里</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"第%d个结点不存在"</span><span class="token punctuation">,</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">-&gt;</span> Next <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"第%d个结点不存在"</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
        s <span class="token operator">=</span> p <span class="token operator">-&gt;</span> Next<span class="token punctuation">;</span><span class="token comment">//s指向第i个结点</span>
        p <span class="token operator">-&gt;</span> Next <span class="token operator">=</span> s <span class="token operator">-&gt;</span> Next<span class="token punctuation">;</span><span class="token comment">//从链表中删除</span>
        <span class="token function">free</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//释放被删除结点</span>
        <span class="token keyword">return</span> PtrL<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">//平均时间复杂度也是n/2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/925/image-20220628010648646.png" alt="image-20220628010648646" style="zoom:50%;"></li>
</ol>
<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/925/image-20220628010948589.png" alt="image-20220628010948589" style="zoom:50%;">

<h3 id="2-1-6-广义表与多重链表"><a href="#2-1-6-广义表与多重链表" class="headerlink" title="2.1.6 广义表与多重链表"></a>2.1.6 广义表与多重链表</h3><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/925/image-20220628012708073.png" alt="image-20220628012708073" style="zoom:50%;">

<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/925/image-20220628012841252.png" alt="image-20220628012841252" style="zoom:50%;">

<p>原本a,b,c所在的位置变成了指针，指向另一个一元多项式。这种就是广义表</p>
<h3 id="广义表-Generalized-List"><a href="#广义表-Generalized-List" class="headerlink" title="广义表(Generalized List)"></a>广义表(Generalized List)</h3><ol>
<li><p>广义表是线性表的推广</p>
</li>
<li><p>对于线性表而言，n个元素都是基本的单元素;</p>
</li>
<li><p>广义表中，这些元素不仅可以是单元素也可以是另一个广义表</p>
</li>
<li><p>广义表可能会碰到的问题：一个域有可能不能分解的单元，有可能是一个指针(C语言的解决方法是使用union(联合))</p>
</li>
<li><p>union(联合)：可以把不同类型的数据组合在一起，可以把这个空间理解成某种类型，也可以理解为另外一种类型</p>
</li>
<li><p>区分类型的方法：再弄个标记</p>
</li>
<li><p>```c<br>typedef struct GNode *GList;<br>struct GNode{<br>int Tag;//标志域：0表示结点时单元素，1表示结点是广义表   这个Tag就是标志<br>union{//子表指针域Sublist与单元素数据域Data复用，即共同存储空间<br>    ElementType Data;<br>    GList SubList;<br>}URegion;<br>GList Next;//指向后续结点<br>};</p>
<pre class="line-numbers language-none"><code class="language-none">
   &lt;img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/925/image-20220628013451554.png" alt="image-20220628013451554" style="zoom:50%;" /&gt;

### 多重链表

**多重链表**：链表中的节点可能同时隶属于多个链

1. 多重链表中结点的指针域会有多个，如前面例子包含了Next和SubList两个指针域;
2. 但包含两个指针域的链表并不一定是多重链表，比如在双向链表不是多重链表。

多重链表有广泛的用途：基本上如树，图这样相对复杂的数据结构都可以采用多重链表的方式实现存储

多重链表指的是它里面的这个链表的结点可能同时隶属于多个链表(意思就是表中的指针会有多个)

&lt;img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/925/image-20220628014523266.png" alt="image-20220628014523266" style="zoom:50%;" /&gt;

稀疏矩阵：矩阵中的0很多，会造成空间浪费

二维数组可以用来表示选课的一种记录

上图中就是用多重链表来表示稀疏矩阵的一种方法

&lt;img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/925/image-20220628015146123.png" alt="image-20220628015146123" style="zoom:50%;" /&gt;

上图中的行与列相互穿插在一起形成十字链表

Head是作为行这个链表的头结点，也作为列这个链表的头结点

Tem：代表稀疏矩阵里面的非零的项

&lt;img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/925/image-20220628015420650.png" alt="image-20220628015420650" style="zoom:40%;" /&gt;

上图：4代表这个稀疏矩阵共有4行，总共有5列，非零项个数总共有7项

通过上图那个指针就可以找到所有列的头节点



在矩阵的多重链表表示中，第i行的head和第i列的head实际上是同一个结点(正确)



1. 用一个标识域Tag来区分头结点和非0元素结点

2. 头节点的标识值为"Head"，矩阵非0元素结点的标识值为"Term"

   &lt;img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/925/image-20220628015932693.png" alt="image-20220628015932693" style="zoom:50%;" /&gt;

经过union的串联在一起，他们共性都是有两个指针：一个Down，一个Right。他们不一样的地方在中间部分。所有我们可以把他们union在一起，形成(a)这个结构

以上就是稀疏矩阵用十字链表解决的一种基本思路

## 2.2.1 什么是堆栈

**计算机如何进行表达式求值？**

&lt;img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/925/image-20220628024357415.png" alt="image-20220628024357415" style="zoom:50%;" /&gt;

由两类对象构成的：

1. 运算数，如2、3、4
2. 运算符号,如+、-、*、/

不同运算符号优先度不一样

**后缀表达式：**运算符号位于两个运算数之后。如abc*+de/-

**中缀表达式：**运算符号位于两个运算数之间。如a+b*c-d/e

两个表达式其实是同一个意思

还有一种表达式叫“**前缀表达式**”，即运算符号位于运算数之前,比如a+b*c的前缀表达式是+a*bc。

你能写出a+b*c-d/e的前缀表达式吗？	正确答案：-+a*bc/de

【例】6 2 / 3 - 4 2 * + = ？   =&gt;   先遇到6然后2接着是/，组成式子得到3，再遇到3然后再遇到-组成式子3-3=0，0接着遇到4跟2然后是*，4 * 2 = 8，然后目前是有0跟8，接着遇到+，相加为8

**后缀表达式求值策略**：从左往右"扫描"，逐个处理运算数和运算符号

1. 遇到运算数怎么办？如何"记住"目前还未参与运算的数？
2. 遇到运算符号怎么办？对应的运算数是什么？
3. 启示：需要有种存储方法，能顺序存储运算数，并在需要时"倒序"输出！
4. 先放进去的后拿出来，后放进去的先拿出来做运算  =&gt;这就是**堆栈**
5. T(N) = O(N)

### 堆栈的抽象数据类型描述

**堆栈(Stack):**具有一定操作约束的线性表

1. 只在一端(栈顶，Top)做插入、删除
2. 插入数据：**入栈(Push)**
3. 删除数据：**出栈(Pop)**
4. **后入先出**：Last In First Out(LIFO) 这是特点

**数据对象集(堆栈)：**一个有0个或者多个元素的有穷线性表

**操作集(堆栈)：**长度为MaxSize的堆栈S 属于Stack，堆栈元素item 属于ElementType

```c
1. Stack CreateStack( int MaxSize)：生成空堆栈，其最大长度为MaxSize;
2. int IsFull(Stack S,int MaxSize)：判断堆栈S是否已满;
3. void Push(Stack S, ElementType item )：将元素item压入堆栈;(重点)相当于插入操作，需要判别堆栈有没有满或空
4. int IsEmpty(Stack S)：判断堆栈S是否为空;
5. ElementType Pop(Stack S)：删除并返回栈顶元素;(重点)相当于删除操作，需要判别堆栈有没有满或空。空了就不能删除了<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/925/image-20220628032111469.png" alt="image-20220628032111469" style="zoom:50%;">

<p><strong>Push和Pop可以穿插交替进行</strong>;</p>
<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/925/image-20220628032222743.png" alt="image-20220628032222743" style="zoom:50%;">

<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/925/image-20220628032242421.png" alt="image-20220628032242421" style="zoom:50%;">

<p>按ABC顺序入栈，可以产生CAB这样的出栈序列？不可以，是CBA序列</p>
<p><strong>Push：推(压入)</strong></p>
<p><strong>Pop：弹出</strong></p>
<h2 id="2-2-2-堆栈的顺序存储实现"><a href="#2-2-2-堆栈的顺序存储实现" class="headerlink" title="2.2.2 堆栈的顺序存储实现"></a>2.2.2 堆栈的顺序存储实现</h2><h3 id="栈的顺序存储实现"><a href="#栈的顺序存储实现" class="headerlink" title="栈的顺序存储实现"></a>栈的顺序存储实现</h3><pre class="line-numbers language-none"><code class="language-none">栈的顺序存储结构通常由一个一维数组和一个记录栈顶元素位置的变量组成<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MaxSize</span> <span class="token expression"><span class="token operator">&lt;</span>存储数据元素的最大个数<span class="token operator">&gt;</span></span></span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">SNode</span> <span class="token operator">*</span>Stack<span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">SNode</span><span class="token punctuation">{</span>
    ElementType Data<span class="token punctuation">[</span>MaxSize<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> Top<span class="token punctuation">;</span><span class="token comment">//用来指示栈顶的位置，Top不是地址而是一个整型变量，代表了栈顶位置它的数组下标在哪里</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">//(1)入栈</span>
<span class="token keyword">void</span> <span class="token function">Push</span> <span class="token punctuation">(</span>Stack PtrS<span class="token punctuation">,</span> ElementType item<span class="token punctuation">)</span><span class="token comment">//包含两个参数，一个是堆栈本身，一个是用指针表示PtrS(Stack类型指针，Stack本身就是堆栈的意思)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span> PtrS <span class="token operator">-&gt;</span> Top <span class="token operator">==</span> MaxSize <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//入栈需要判断堆栈满了没有，满了就不能再加了，有极限的。下标从0开始，所以到MaxSize-1就已经满了</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"堆栈满"</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
        PtrS <span class="token operator">-&gt;</span>Data<span class="token punctuation">[</span><span class="token operator">++</span><span class="token punctuation">(</span>PtrS <span class="token operator">-&gt;</span> Top<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> item<span class="token punctuation">;</span><span class="token comment">//item放在Top上面的一个位置，这一个语句实际做了两个事情，一是把item放到Top+1这个位置上，同时把Top值加实现了入栈的操作</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">//(2)出栈</span>
ElementType <span class="token function">Pop</span><span class="token punctuation">(</span>Stack PtrS<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>PtrS <span class="token operator">-&gt;</span> Top <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"堆栈空"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//一样的操作，出栈之前要检查以下是不是空了，空了可就没东西往外掏了</span>
        <span class="token keyword">return</span> ERROR<span class="token punctuation">;</span><span class="token comment">//ERROR是ElementType的特殊值，标志错误</span>
    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span><span class="token punctuation">(</span>PtrS <span class="token operator">-&gt;</span> Data<span class="token punctuation">[</span><span class="token punctuation">(</span>PriS <span class="token operator">-&gt;</span> Top<span class="token punctuation">)</span><span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c" data-language="c"><code class="language-c">【例】请用一个数组实现两个堆栈，要求最大地利用数组空间，使数组只要有空间入栈操作就可以成功
<span class="token comment">//简单将把数组对分的话来做两个堆栈会有一个问题：有一个堆栈满了，但另一个堆栈是空的，还有空余空间</span>
<span class="token comment">//要求是数组还有空余空间，就允许有入栈操作</span>
<span class="token comment">//用法就是一个从最左边往里放，另一个从最右边往里放。中间就是空余的大家都可以用</span>

<span class="token comment">//根据刚才讲的方法，用一个数组来表示双堆栈，如果这两个堆栈的栈顶位置分别是top1和top2，那么可以用top1+top2==MaxSize(数组大小）来判别堆栈是否满？不可以</span>
<span class="token comment">//因为top1跟top2代表的是数组的下标，所以top1代表的距离是中间空余的位置＋top2，top2也是同理</span>

<span class="token comment">//正确的分析：使这两个栈分别从数组的两头开始向中间生长；当两个栈的栈顶指针相遇时，表示两个栈都满了</span>
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MaxSize</span><span class="token expression"><span class="token operator">&lt;</span>存储数据元素的最大个数<span class="token operator">&gt;</span></span></span>
    <span class="token keyword">struct</span> <span class="token class-name">DStack</span><span class="token punctuation">{</span>
        ElementType Data<span class="token punctuation">[</span>MaxSize<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> Top1<span class="token punctuation">;</span><span class="token comment">//堆栈1的栈顶指针</span>
        <span class="token keyword">int</span> Top2<span class="token punctuation">;</span><span class="token comment">//堆栈2的栈顶指针</span>
    <span class="token punctuation">}</span>S<span class="token punctuation">;</span>
	S<span class="token punctuation">.</span>Top1 <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//这是堆栈1空的位置</span>
	S<span class="token punctuation">.</span>Top2 <span class="token operator">=</span> MaxSzie<span class="token punctuation">;</span><span class="token comment">//堆栈2空的位置，数组最后一个位置是MaxSize - 1</span>

<span class="token comment">//Push(弹出)具体操作</span>
<span class="token keyword">void</span> <span class="token function">Push</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">DStack</span> <span class="token operator">*</span>PtrS<span class="token punctuation">,</span>ElementType item<span class="token punctuation">,</span><span class="token keyword">int</span> Tag <span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">//Tag作为区分两个堆栈的标志，取值为1和2，Tag的值1和2分别代表第一个堆栈跟第二个堆栈</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span> PtrS <span class="token operator">-&gt;</span> Top2 <span class="token operator">-</span> PtrS <span class="token operator">-&gt;</span> Top1 <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"堆栈满"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span> Tag <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">//对第一个堆栈操作</span>
        PtrS <span class="token operator">-&gt;</span> Data<span class="token punctuation">[</span><span class="token operator">++</span><span class="token punctuation">(</span>PtrS <span class="token operator">-&gt;</span> Top1<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> item<span class="token punctuation">;</span><span class="token comment">//Top1后面一个位置</span>
    <span class="token keyword">else</span><span class="token comment">//对第二个堆栈进行操作</span>
        PtrS <span class="token operator">-&gt;</span> Data<span class="token punctuation">[</span><span class="token operator">--</span><span class="token punctuation">(</span>PtrS <span class="token operator">-&gt;</span> Top2<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> item<span class="token punctuation">;</span><span class="token comment">//Top2前面一个位置</span>
<span class="token punctuation">}</span>

<span class="token comment">//Pop(压入)操作</span>
ElementType <span class="token function">Pop</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">DStack</span> <span class="token operator">*</span>PtrS<span class="token punctuation">,</span><span class="token keyword">int</span> Tag <span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">//Tag作为区分两个堆栈的标志，取值为1和2，Tag的值1和2分别代表第一个堆栈跟第二个堆栈</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span> Tag <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//对第一个堆栈进行操作</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span> PtrS <span class="token operator">-&gt;</span> Top1 <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//堆栈1空</span>
         	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"堆栈1空"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> PtrS <span class="token operator">-&gt;</span> Data <span class="token punctuation">[</span><span class="token punctuation">(</span>PtrS <span class="token operator">-&gt;</span> Top1<span class="token punctuation">)</span><span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span><span class="token comment">//对第二个堆栈操作</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span> PtrS <span class="token operator">-&gt;</span> Top2 <span class="token operator">==</span> MaxSize<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//堆栈2空</span>
    	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"堆栈2空"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    
    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
     <span class="token keyword">return</span> PtrS <span class="token operator">-&gt;</span> Data<span class="token punctuation">[</span><span class="token punctuation">(</span>PtrS <span class="token operator">-&gt;</span> Top2<span class="token punctuation">)</span><span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>以下部分是百度内容(对堆栈的总结)</p>
<pre class="line-numbers language-none"><code class="language-none">堆栈严格来说应该叫做栈（stack），先入后出

四种类型：满增栈、满减栈、空增栈、空减栈。

 

满、空栈区别：根据当前指针所在位置是否有东西。

满栈（full stack）：栈指针指向最后压入栈的数据，数据入栈时，sp先减一（或加一）再入栈。

空栈（empty stack）：栈指针指向下一个将要放入数据的位置，数据入栈时，先入栈sp再减一（或加一）。

 

增、减栈区别：根据堆栈的生成方向不同。

递增堆栈(ascending stack)：堆栈由低地址向高地址生长。

递减堆栈(secending stack)：堆栈由高地址向低地址生长。

 

总结：

 

满栈进栈是先移动指针再存；

满栈出栈是先出数据再移动指针；

空栈进栈先存再移动指针；

空栈出栈先移动指针再取数据。
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="2-2-3-堆栈的链式存储实现"><a href="#2-2-3-堆栈的链式存储实现" class="headerlink" title="2.2.3 堆栈的链式存储实现"></a>2.2.3 堆栈的链式存储实现</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">栈的链式存储结构实际上就是一个单链表，叫做链栈。插入和删除操作只能再链栈的栈顶进行。
栈顶指针Top应该再链表的哪一头？若用单向链表实现一个堆栈，链表的头和尾都可以作为top？
只有链表的头才行。链表的尾空余插入，但是删除就有问题，找不到前面的结点了，因为这是单项链表找不到前面的结点
    
    <span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">SNode</span><span class="token operator">*</span>Stack<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">SNode</span><span class="token punctuation">{</span>
        ElementType Data<span class="token punctuation">;</span>
        <span class="token keyword">struct</span> <span class="token class-name">SNode</span><span class="token operator">*</span>Next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/925/image-20220628045906099.png" alt="image-20220628045906099" style="zoom:50%;">

<pre class="line-numbers language-C" data-language="C"><code class="language-C">Stack CreateStack()
{//构建一个堆栈的头结点，返回指针
    Stack S;
    S = (Stack)malloc(sizeof(struct SNode));
    s-&gt;Next = NULL;
    return S;
}

int IsEmpty(Stack S)
{
    //判断堆栈s是否为空，若为空函数返回整数1，否则返回0
    return (S-&gt;Next == NULL);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/925/image-20220628050006254.png" alt="image-20220628050006254" style="zoom:50%;">

<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">Push</span><span class="token punctuation">(</span>ElementType item<span class="token punctuation">,</span>Stack S<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token comment">//将元素item压入堆栈S</span>
	<span class="token keyword">struct</span> <span class="token class-name">SNode</span> <span class="token operator">*</span>TmpCell<span class="token punctuation">;</span>
    TmpCell <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">SNode</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">SNode</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    TmpCell <span class="token operator">-&gt;</span> Element <span class="token operator">=</span> item<span class="token punctuation">;</span>
    TmpCell <span class="token operator">-&gt;</span> Next <span class="token operator">=</span> S <span class="token operator">-&gt;</span> Next<span class="token punctuation">;</span>
    S <span class="token operator">-&gt;</span> Next <span class="token operator">=</span> TmpCell<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>使用链表来进行Push操作的时候不用判别堆栈满不满的问题，因为链表通过不断申请结点空间往里面插</p>
<p>数组实现堆栈的话，数组大小是固定的，存在着满不满的问题</p>
<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/925/image-20220628050745839.png" alt="image-20220628050745839" style="zoom:50%;">

<pre class="line-numbers language-c" data-language="c"><code class="language-c">ElementType <span class="token function">Pop</span><span class="token punctuation">(</span>Stack S<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token comment">//删除并返回堆栈s的栈顶元素</span>
    <span class="token keyword">struct</span> <span class="token class-name">SNode</span> <span class="token operator">*</span>FirstCell<span class="token punctuation">;</span>
    ElementType TopElem<span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token function">IsEmpty</span> <span class="token punctuation">(</span>S<span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"堆栈空"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
        FirstCell <span class="token operator">=</span> S <span class="token operator">-&gt;</span>Next<span class="token punctuation">;</span>
        TopElem <span class="token operator">=</span> FirstCell <span class="token operator">-&gt;</span> Element<span class="token punctuation">;</span>
        <span class="token function">free</span><span class="token punctuation">(</span>FirstCell<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> TopElem<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="2-2-4-堆栈应用：表达式求值"><a href="#2-2-4-堆栈应用：表达式求值" class="headerlink" title="2.2.4 堆栈应用：表达式求值"></a>2.2.4 堆栈应用：表达式求值</h2><h3 id="回忆：应用堆栈实现后缀表达式求值的基本过程："><a href="#回忆：应用堆栈实现后缀表达式求值的基本过程：" class="headerlink" title="回忆：应用堆栈实现后缀表达式求值的基本过程："></a>回忆：应用堆栈实现后缀表达式求值的基本过程：</h3><ol>
<li>从左到右读入后缀表达式的各项(运算符或运算数);</li>
</ol>
<pre class="line-numbers language-none"><code class="language-none">1.运算数：入栈;
2.运算符：从堆栈中弹出适当数量的运算数，计算并结果入栈;
3.最后，堆栈顶上的元素就是表达式的结果值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h3 id="中缀表达式求值"><a href="#中缀表达式求值" class="headerlink" title="中缀表达式求值"></a>中缀表达式求值</h3><pre class="line-numbers language-none"><code class="language-none">基本策略：将中缀表达式转化为后缀表达式，然后求值
如何将中缀表达式转化为后缀？
观察一个简单例子：2+9/3-5  -&gt;  2 9 3 / + 5 -
1.运算数相对顺序不变
2.运算符号顺序发生改变
	1.需要存储"等待中"的运算符号
	2.要将当前运算符号与"等待中"的最后一个运算符号比较(如果前面的一个运算符号的优先级比我来得高，就说明可以拿来计算，如果优先度比我低，那么当前的运算符号还不能说就直接拿来运算，因为后面可能还有优先级比我高的，所以需要保留起来，这个时候我们就需要一种结构来实现我们运算符号的存储，那结构就是堆栈)
		输出：2 9 3
		记下：+ /
		碰到运算数 我们就把它输出
		碰到运算符号 我们等着
		
有括号怎么办？
【例】a*(b+c)/d = ?		a b c + * d /
当括号被丢进堆栈里面的时候，它的优先级降到最低，优先算括号里的内容
算数规则：当遇到同一个优先级的时候，它的顺序是从左到右

T(N) = O(N)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/925/image-20220628210030460.png" alt="image-20220628210030460" style="zoom:50%;">

<p>请试试应用堆栈将中缀表达式2*(6/3+4)-5转换为后缀表达式。在这个转换过程中，堆栈元素最多时元素个数是多少？3个</p>
<pre class="line-numbers language-none"><code class="language-none">中缀表达式如何转换为后缀表达式
从头到尾读取中缀表达式的每个对象，对不同对象按不同的情况处理。
1.运算数：直接输出
2.左括号：压入堆栈
3.右括号：将栈顶的运算符弹出并输出，直到遇到左括号(出栈，不输出);
4.运算符：
	1.若优先级大于栈顶运算符时，则把它压栈;
	2.若优先级小于等于栈顶运算符时，将栈顶运算符弹出并输出;再比较新的栈顶运算符，直到该运算符大于栈顶运算符优先级为止，然后将该运算符压栈;
5.若各对象处理完毕，则把堆栈中存留的运算符一并输出<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/925/image-20220628215153143.png" alt="image-20220628215153143" style="zoom:50%;">

<pre class="line-numbers language-none"><code class="language-none">堆栈的其他应用：
函数的调用及递归实现
深度优先搜索(图)
回溯算法(老鼠走迷宫案例)等等<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="2-3-队列及实现"><a href="#2-3-队列及实现" class="headerlink" title="2.3 队列及实现"></a>2.3 队列及实现</h2><p>队列跟堆栈一样是一种受限制的线性表</p>
<h3 id="什么是队列"><a href="#什么是队列" class="headerlink" title="什么是队列"></a>什么是队列</h3><p><strong>队列(Queue)：</strong>具有一定操作约束的线性表</p>
<ol>
<li>插入和删除操作：只能一端插入，而在另一端删除(一般的线性表都可以在任何位置进行插入和删除)</li>
<li>跟堆栈相比：堆栈插入和删除都是只能在一端</li>
<li>数据插入：<strong>入队列(AddQ)</strong></li>
<li>数据删除：<strong>出队列</strong>(<strong>DeleteQ</strong>)</li>
<li>先来先服务(跟堆栈相反)</li>
<li>先进先出：FIFO</li>
</ol>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">队列的抽象数据类型描述
    类型名称<span class="token operator">:</span>队列<span class="token punctuation">(</span>Queue<span class="token punctuation">)</span>
    数据对象集：一个有<span class="token number">0</span>个或多个元素的有穷线性表
    操作集：长度为MaxSize的队列Q属于Queue，队列元素item属于ElementType
        
        <span class="token number">1.</span>Queue <span class="token function">CreateQueue</span><span class="token punctuation">(</span> <span class="token keyword">int</span> MaxSize <span class="token punctuation">)</span>：生成长度为MaxSize的空队列；
        <span class="token number">2.</span><span class="token keyword">int</span> <span class="token function">IsFullQ</span><span class="token punctuation">(</span>Queue Q<span class="token punctuation">,</span><span class="token keyword">int</span> MaxSize<span class="token punctuation">)</span>：判断队列Q是否已满<span class="token punctuation">;</span>
		<span class="token number">3.</span><span class="token keyword">void</span> <span class="token function">AddQ</span><span class="token punctuation">(</span>Queue Q<span class="token punctuation">,</span><span class="token keyword">int</span> MaxSize<span class="token punctuation">)</span>：将数据元素item插入队列Q中
        <span class="token number">4.</span><span class="token keyword">int</span> <span class="token function">IsEmptyQ</span><span class="token punctuation">(</span> Queue Q<span class="token punctuation">)</span><span class="token operator">:</span>判断队列Q是否为空<span class="token punctuation">;</span>
		<span class="token number">5.</span>ElementType <span class="token function">DeleteQ</span><span class="token punctuation">(</span> Queue Q<span class="token punctuation">)</span><span class="token operator">:</span>将队头元素从队列中删除并返回<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="2-3-1-队列的顺序存储实现"><a href="#2-3-1-队列的顺序存储实现" class="headerlink" title="2.3.1 队列的顺序存储实现"></a>2.3.1 队列的顺序存储实现</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">队列的顺序存储结构通常由一个一维数组和一个记录队列头元素位置的变量front以及一个记录队列尾元素位置的变量rear组成的

    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MaxSize</span> <span class="token expression"><span class="token operator">&lt;</span>储存数据元素的最大个数<span class="token operator">&gt;</span></span></span>
    <span class="token keyword">struct</span> <span class="token class-name">QNode</span><span class="token punctuation">{</span>
        ElementType Data<span class="token punctuation">[</span>MaxSize<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> rear<span class="token punctuation">;</span><span class="token comment">//指针</span>
        <span class="token keyword">int</span> front<span class="token punctuation">;</span><span class="token comment">//指针</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">QNode</span> <span class="token operator">*</span>Queue<span class="token punctuation">;</span>

如果空队列开始时front和rear值都是<span class="token operator">-</span><span class="token number">1</span>，当插入<span class="token number">4</span>个元素并删除<span class="token number">2</span>个元素后，front和rear值分别是多少？<span class="token number">1</span>和<span class="token number">3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="顺环队列"><a href="#顺环队列" class="headerlink" title="顺环队列"></a>顺环队列</h4><pre class="line-numbers language-none"><code class="language-none">1.这种方案：堆栈空和满的判别条件是什么？
根据front rear的相对关系(就是他们的距离)来判别的font rear的取值范围是0 -- n-1
2.为什么会出现空，满无法区分？根本原因？
如果大小是n的话，font跟rear的差距的情况就是n种，队列的装载元素的情况有n+1种
解决方案：
(1)使用额外标记：Size或者tag域
当加入一个元素的时候Szie加1，删除一个元素的时候Size减1，通过Size等于0还是等于n就可以知道空的还是满的
使用标记tag 0 1，当我们插入一个元素的时候tag设为1，删除一个元素的时候tag等于0，当front跟rear相等时不清楚空还是满的时候，观察tag，tag就代表了最后一次操作是插入还是删除，就知道是空还是满
(2)仅使用n-1个数组空间(最多放n-1个元素，留一个空位出来就可以避免front跟rear相等的情况)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>(1)入队列</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">AddQ</span><span class="token punctuation">(</span>Queue PtrQ<span class="token punctuation">,</span>ElementType item<span class="token punctuation">)</span><span class="token comment">//item放到队列中 队列使用Queue的结构指针PtrQ来进行表示</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>PtrQ <span class="token operator">-&gt;</span> rear<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>MaxSize <span class="token operator">==</span> PtrQ <span class="token operator">-&gt;</span> front<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//具体代换：5+1对6求余为0</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"队列满"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    PtrQ <span class="token operator">-&gt;</span> rear <span class="token operator">=</span> <span class="token punctuation">(</span>PtrQ <span class="token operator">-&gt;</span> rear<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>MaxSize<span class="token punctuation">;</span>
    PtrQ <span class="token operator">-&gt;</span> Data<span class="token punctuation">[</span>PtrQ <span class="token operator">-&gt;</span> rear<span class="token punctuation">]</span> <span class="token operator">=</span> item<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>(2)出队列</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">ElementType <span class="token function">DeleteQ</span><span class="token punctuation">(</span> Queue PtrQ<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>PtrQ <span class="token operator">-&gt;</span> front <span class="token operator">==</span> PtrQ <span class="token operator">-&gt;</span> rear<span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"队列空"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> ERROR<span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
		PtrQ <span class="token operator">-&gt;</span> front <span class="token operator">=</span> <span class="token punctuation">(</span>PtrQ <span class="token operator">-&gt;</span> front<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>MaxSize<span class="token punctuation">;</span>
		<span class="token keyword">return</span> PtrQ <span class="token operator">-&gt;</span> Data<span class="token punctuation">[</span>PtrQ <span class="token operator">-&gt;</span> front<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="2-3-2-队列的链式存储实现"><a href="#2-3-2-队列的链式存储实现" class="headerlink" title="2.3.2 队列的链式存储实现"></a>2.3.2 队列的链式存储实现</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">队列的链式存储结构也可以用一个单链表实现。插入和删除操作分别在链表的两头进行；队列指针front和rear应该分别指向链表的哪一头？
队列的front也可以设在链表的尾？错误，不行的 
只能前面做删除<span class="token punctuation">(</span>front<span class="token punctuation">)</span>，后面做加入<span class="token punctuation">(</span>rear<span class="token punctuation">)</span>，如果倒过来的话，删掉了就不知道前面一个在哪里了
    
    <span class="token keyword">struct</span> <span class="token class-name">Node</span><span class="token punctuation">{</span>
        ElementType Data<span class="token punctuation">;</span><span class="token comment">//结点本身的信息</span>
        <span class="token keyword">struct</span> <span class="token class-name">Node</span> <span class="token operator">*</span>Next<span class="token punctuation">;</span><span class="token comment">//把结点串在一起</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">QNode</span><span class="token punctuation">{</span><span class="token comment">//链队列结构</span>
    <span class="token keyword">struct</span> <span class="token class-name">Node</span> <span class="token operator">*</span>rear<span class="token punctuation">;</span><span class="token comment">//指向队尾结点</span>
    <span class="token keyword">struct</span> <span class="token class-name">Node</span> <span class="token operator">*</span>front<span class="token punctuation">;</span><span class="token comment">//指向队头结点</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">QNode</span> <span class="token operator">*</span>Queue<span class="token punctuation">;</span>
Queue PtrQ<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/925/image-20220629041503372.png" alt="image-20220629041503372" style="zoom:50%;">

<p><strong>不带头结点的链式队列出队操作的示例</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">ElementType <span class="token function">DeleteQ</span><span class="token punctuation">(</span>Queue PtrQ<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">struct</span> <span class="token class-name">Node</span> <span class="token operator">*</span>FrontCell<span class="token punctuation">;</span>
    ElementType FrontElem<span class="token punctuation">;</span>
    
    <span class="token keyword">if</span><span class="token punctuation">(</span>PtrQ <span class="token operator">-&gt;</span> front <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"队列空"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">return</span> ERROR<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    FrontCell <span class="token operator">=</span> PtrQ <span class="token operator">-&gt;</span> front<span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>PtrQ <span class="token operator">-&gt;</span> front <span class="token operator">==</span> PtrQ <span class="token operator">-&gt;</span> rear<span class="token punctuation">)</span><span class="token comment">//若队列只有一个元素</span>
        PtrQ <span class="token operator">-&gt;</span> front <span class="token operator">=</span> PtrQ <span class="token operator">-&gt;</span> rear <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token comment">//删除后队列置为空</span>
    <span class="token keyword">else</span>
        PtrQ <span class="token operator">-&gt;</span> front <span class="token operator">=</span> PtrQ <span class="token operator">-&gt;</span> front <span class="token operator">-&gt;</span> Next<span class="token punctuation">;</span>
    FrontElem <span class="token operator">=</span> FrontCell <span class="token operator">-&gt;</span> Data<span class="token punctuation">;</span>
    <span class="token function">free</span><span class="token punctuation">(</span>FrontCell<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//释放被删除结点空间</span>
    <span class="token keyword">return</span> FrontElem<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="2-4-多项式的加法运算实现"><a href="#2-4-多项式的加法运算实现" class="headerlink" title="2.4 多项式的加法运算实现"></a>2.4 多项式的加法运算实现</h2><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/925/image-20220629052314628.png" alt="image-20220629052314628" style="zoom:50%;">

<pre class="line-numbers language-none"><code class="language-none">采用不带头结点的单项链表，按照指数递减的顺序排列各项<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/925/image-20220629052450477.png" alt="image-20220629052450477" style="zoom:50%;">

<pre class="line-numbers language-c" data-language="c"><code class="language-c">具体实现代码<span class="token punctuation">(</span>数据结构<span class="token punctuation">)</span>
<span class="token keyword">struct</span> <span class="token class-name">PolyNode</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> coef<span class="token punctuation">;</span><span class="token comment">//系数</span>
    <span class="token keyword">int</span> expon<span class="token punctuation">;</span><span class="token comment">//指数</span>
    <span class="token keyword">struct</span> <span class="token class-name">PolyNode</span> link<span class="token punctuation">;</span><span class="token comment">//指向下一个节点的指针</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">PolyNode</span><span class="token operator">*</span>Polynomial<span class="token punctuation">;</span>
Polynomial P1<span class="token punctuation">,</span>P2<span class="token punctuation">;</span>

多项式加法运算<span class="token punctuation">(</span>算法思路<span class="token punctuation">)</span><span class="token operator">:</span>
两个指针p1和p2分别指向这两个多项式第一个结点，不断循环：
    <span class="token number">1.</span> P1<span class="token operator">-&gt;</span>expon <span class="token operator">==</span> P2 <span class="token operator">-&gt;</span> <span class="token function">expon</span><span class="token punctuation">(</span>这里比较的其实是指数<span class="token punctuation">)</span>：系数相加，若结果不为<span class="token number">0</span>，则作为结果多项式对应项的系数。同时，P1和P2都分别指向下一项
    <span class="token number">2.</span> P1<span class="token operator">-&gt;</span>expon <span class="token operator">&gt;</span> P2 <span class="token operator">-&gt;</span> expon：将P1的当前项存入结果多样式，并使P1指向下一项<span class="token punctuation">;</span>
    <span class="token number">3.</span> P1<span class="token operator">-&gt;</span>expon <span class="token operator">&lt;</span> P2 <span class="token operator">-&gt;</span> expon：将P2的当前项存入结果多样式，并使P2指向下一项<span class="token punctuation">;</span>

当某一多项式处理完时，将另一个多项式的所有结点依次复制到结果多项式中去<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/925/image-20220629060519985.png" alt="image-20220629060519985" style="zoom:50%;">

<p>演变过程————————分割线</p>
<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/925/image-20220629060715728.png" alt="image-20220629060715728" style="zoom:50%;">

<p>接着是=&gt;</p>
<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/925/image-20220629060827486.png" alt="image-20220629060827486" style="zoom:50%;">

<pre class="line-numbers language-c" data-language="c"><code class="language-c">函数实现
Polynomial <span class="token function">PolyAdd</span><span class="token punctuation">(</span>Polynomial P1<span class="token punctuation">.</span>Polynomial P2<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    Polynomial front<span class="token punctuation">,</span>rear<span class="token punctuation">,</span>temp<span class="token punctuation">;</span><span class="token comment">//多项式的头是第一个，尾巴第二个，</span>
    <span class="token keyword">int</span> sum<span class="token punctuation">;</span>
    rear <span class="token operator">=</span> <span class="token punctuation">(</span>Polynomial<span class="token punctuation">)</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">PolyNode</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//临时申请一个空结点作为结果多项式的表头</span>
    front <span class="token operator">=</span> rear<span class="token punctuation">;</span><span class="token comment">//由front记录结果多项式链表头结点，申请的空间front都指向它</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>P1 <span class="token operator">&amp;&amp;</span> P2<span class="token punctuation">)</span><span class="token comment">//当两个多项式都有非零待处理时(判空)</span>
        <span class="token keyword">switch</span><span class="token punctuation">(</span><span class="token function">Compare</span><span class="token punctuation">(</span>P1<span class="token operator">-&gt;</span>expon<span class="token punctuation">,</span>P2<span class="token operator">-&gt;</span>expon<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//比较P1P2这两个项的所指向的当前这个项的指数，第一个值大返回1，第二个值大返回-1，两个值相等返回0</span>
                case1<span class="token operator">:</span><span class="token comment">//P1大</span>
                		<span class="token function">Attach</span><span class="token punctuation">(</span>P1<span class="token operator">-&gt;</span>coef<span class="token punctuation">,</span>P1<span class="token operator">-&gt;</span>expon<span class="token punctuation">,</span><span class="token operator">&amp;</span>rear<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//两个参数分别代表我要拷贝的这一项的系数和指数</span>
                		P1 <span class="token operator">=</span> P1 <span class="token operator">-&gt;</span> link<span class="token punctuation">;</span>
                		<span class="token keyword">break</span><span class="token punctuation">;</span><span class="token comment">//形成的新的项把它接到rear的后面，P1往后挪</span>
                <span class="token keyword">case</span><span class="token operator">-</span><span class="token number">1</span>：<span class="token comment">//P2大</span>
                    	<span class="token function">Attach</span><span class="token punctuation">(</span>P2<span class="token operator">-&gt;</span>coef<span class="token punctuation">,</span>P2<span class="token operator">-&gt;</span>expon<span class="token punctuation">,</span><span class="token operator">&amp;</span>rear<span class="token punctuation">)</span><span class="token punctuation">;</span>
                		P2 <span class="token operator">=</span> P2 <span class="token operator">-&gt;</span> link<span class="token punctuation">;</span>
                		<span class="token keyword">break</span><span class="token punctuation">;</span>
                case0<span class="token operator">:</span><span class="token comment">//一样大</span>
                        sum <span class="token operator">=</span> P1<span class="token operator">-&gt;</span>coef <span class="token operator">+</span> P2<span class="token operator">-&gt;</span>coef<span class="token punctuation">;</span>
                		<span class="token keyword">if</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span><span class="token function">Attach</span><span class="token punctuation">(</span>sum<span class="token punctuation">.</span>P1<span class="token operator">-&gt;</span>expon<span class="token punctuation">,</span><span class="token operator">&amp;</span>rear<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//判定，如果为0就不用加到结果多项式里面去，不为零就把sum作为系数跟对于的指数凑在一起，把他接到rear的后面去</span>
                		P1 <span class="token operator">=</span> P1 <span class="token operator">-&gt;</span> link<span class="token punctuation">;</span>
                		P2 <span class="token operator">=</span> P2 <span class="token operator">-&gt;</span> link<span class="token punctuation">;</span>
                		<span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token comment">//将未处理完的另一个多项式的所有节点依次复制到结果多项式中去</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span>P1<span class="token punctuation">;</span>P1 <span class="token operator">=</span> P1 <span class="token operator">-&gt;</span> link<span class="token punctuation">)</span> <span class="token function">Attach</span><span class="token punctuation">(</span>P1<span class="token operator">-&gt;</span>coef<span class="token punctuation">,</span>P1<span class="token operator">-&gt;</span>expon<span class="token punctuation">,</span><span class="token operator">&amp;</span>rear<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//第一个for循环处理P1不空，如果不空就是把P1后面的每一项全部Attach(接到结果多项式的后面的意思)，同时把P1往后挪</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span>P2<span class="token punctuation">;</span>P2 <span class="token operator">=</span> P2 <span class="token operator">-&gt;</span> link<span class="token punctuation">)</span> <span class="token function">Attach</span><span class="token punctuation">(</span>P2<span class="token operator">-&gt;</span>coef<span class="token punctuation">,</span>P2<span class="token operator">-&gt;</span>expon<span class="token punctuation">,</span><span class="token operator">&amp;</span>rear<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//如果P1不空的话P2肯定就空了，也就把P2后面的每一项一个一个拷贝到rear的后面去</span>
    rear <span class="token operator">-&gt;</span>link <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token comment">//指向结果多项式的最后一项</span>
    temp <span class="token operator">=</span> front<span class="token punctuation">;</span>
    front <span class="token operator">=</span> front <span class="token operator">-&gt;</span> link<span class="token punctuation">;</span><span class="token comment">//令front指向结果多项式第一个非零项</span>
    <span class="token function">free</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//释放临时空表头结点  怎么释放？=&gt;将front赋给temp，然后front往后挪，front原来是指向这个临时的表头结点，这个表头结点的下一项就是我们真正的多项式的第一项 </span>
    <span class="token keyword">return</span> front<span class="token punctuation">;</span><span class="token comment">//返回结果多样式中这个单项链表的第一个结点</span>
<span class="token punctuation">}</span>

问题：如果当前p1指向项的（系数，指数）为（<span class="token number">2</span>，<span class="token number">4</span>），同时P2指向项为<span class="token punctuation">(</span><span class="token number">2</span>，<span class="token number">6</span><span class="token punctuation">)</span>，那么循环中的<span class="token keyword">switch</span>是执行哪个<span class="token keyword">case</span><span class="token operator">?</span>
<span class="token keyword">case</span> <span class="token operator">-</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c" data-language="c"><code class="language-c">Attach实现
<span class="token keyword">void</span> <span class="token function">Attach</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">,</span><span class="token keyword">int</span> e<span class="token punctuation">,</span>Polynomial<span class="token operator">*</span>pRear<span class="token punctuation">)</span><span class="token comment">//传进来的是c跟e的系数跟指数。当前最后一个结点的指针位置传进来的是Polynomial这个类型的指针(Polynomial本身也是指针)，所以pRear实际上是指针的指针</span>
    <span class="token comment">//C语言是函数常数值传递</span>
<span class="token punctuation">{</span>
	Polynomial P<span class="token punctuation">;</span>
	
	P <span class="token operator">=</span> <span class="token punctuation">(</span>Polynomial<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">PloyNode</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//结点类型是struct PolyNode这个类型</span>
	P <span class="token operator">-&gt;</span> coef <span class="token operator">=</span> c<span class="token punctuation">;</span><span class="token comment">//对新结点赋值</span>
	P <span class="token operator">-&gt;</span> expon <span class="token operator">=</span> e<span class="token punctuation">;</span>
	P <span class="token operator">-&gt;</span> link <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
	<span class="token punctuation">(</span><span class="token operator">*</span>pRear<span class="token punctuation">)</span><span class="token operator">-&gt;</span>link <span class="token operator">=</span> P<span class="token punctuation">;</span><span class="token comment">//把新申请的结点P插到rear的后面</span>
	<span class="token operator">*</span>pRear <span class="token operator">=</span> P<span class="token punctuation">;</span><span class="token comment">//修改pRear值</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/925/image-20220629070700010.png" alt="image-20220629070700010" style="zoom:50%;">

<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/925/image-20220629070712967.png" alt="image-20220629070712967" style="zoom:50%;">

<h2 id="小白专场"><a href="#小白专场" class="headerlink" title="小白专场"></a>小白专场</h2><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/925/image-20220629071856844.png" alt="image-20220629071856844" style="zoom:50%;">

<h4 id="多项式的表示"><a href="#多项式的表示" class="headerlink" title="多项式的表示"></a>多项式的表示</h4><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/925/image-20220629072141892.png" alt="image-20220629072141892" style="zoom:50%;">

<pre class="line-numbers language-c" data-language="c"><code class="language-c">用链表进行表示
    数据结构设计
    <span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">PolyNode</span> <span class="token operator">*</span>Polynomial<span class="token punctuation">;</span><span class="token comment">//将结构指针定义为一个新的类型叫做Polynomial</span>
<span class="token keyword">struct</span> <span class="token class-name">PolyNode</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> coef<span class="token punctuation">;</span><span class="token comment">//系数</span>
    <span class="token keyword">int</span> expon<span class="token punctuation">;</span><span class="token comment">//指数</span>
    Polynomial link<span class="token punctuation">;</span><span class="token comment">//阈，作为指针指向下一个节点</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="程序框架搭建"><a href="#程序框架搭建" class="headerlink" title="程序框架搭建"></a>程序框架搭建</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    读入多项式<span class="token number">1</span>
    读入多项式<span class="token number">2</span>
    乘法运算并输出
    加法运算并输出
        
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
需要设计的函数：
    <span class="token number">1.</span>读一个多项式
    <span class="token number">2.</span>两多项式相乘
    <span class="token number">3.</span>两多项式相加
    <span class="token number">4.</span>多项式输出
   
    <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    Polynomial P1<span class="token punctuation">,</span>P2<span class="token punctuation">,</span>PP<span class="token punctuation">,</span>PS<span class="token punctuation">;</span>
    
    P1 <span class="token operator">=</span> <span class="token function">ReadPoly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    P2 <span class="token operator">=</span> <span class="token function">ReadPoly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//P1,P2都是链表的结构的指针</span>
    PP <span class="token operator">=</span> <span class="token function">Mult</span><span class="token punctuation">(</span>P1<span class="token punctuation">,</span>P2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//Mult是乘法运算，返回的也是一个结构的指针</span>
    <span class="token function">PrintPoly</span><span class="token punctuation">(</span>PP<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//由PrintPoly来输出多项式</span>
    PS <span class="token operator">=</span> <span class="token function">Add</span><span class="token punctuation">(</span>P1<span class="token punctuation">,</span>P2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//加法运算 </span>
    <span class="token function">PrintPoly</span><span class="token punctuation">(</span>PS<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

如何读入多项式
    Polynomial <span class="token function">ReadPoly</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">//先读整数再一对一的读入系数跟指数</span>
        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>N<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>N<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//这是读入系数跟指数，放到c跟e里面</span>
        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d %d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>c<span class="token punctuation">,</span><span class="token operator">&amp;</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    	<span class="token function">Attach</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span>e<span class="token punctuation">,</span><span class="token operator">&amp;</span>Rear<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//读的时候是通过指数递降的顺序来读取的，Rear是可以被改变的，Rear是指向目前为止多项式的最后一项</span>
        <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">//注意：我们是从左到右读入的，而且先读的是指数高的一项，要插到一个链表里面去，然后再读一对数再插进去，再形成一个节点</span>
<span class="token comment">//再读一对系数指数，再插到多项式里面去，在链表里面也是指数递降的，应该插到原来结果的后面</span>

Rear初始值是多少？
    两种处理方法：
    <span class="token number">1.</span>Rear初值为<span class="token constant">NULL</span><span class="token punctuation">(</span>说明是刚开始的一个节点，这个时候需要申请节点，然后把Rear用<span class="token constant">NULL</span>改为指向这个节点<span class="token punctuation">)</span>
    在Attach函数中根据Rear是否为<span class="token constant">NULL</span>做不同处理
    如果值不为<span class="token constant">NULL</span>，因为从第二项开始Rear值就不为<span class="token constant">NULL</span>了。这个时候直接把新的节点插到Rear的后面。这样的一种处理方式在Attach函数里面他必须判别Rear是<span class="token constant">NULL</span>还是说不是<span class="token constant">NULL</span>，因为这两者处理的程序是不一样的
    <span class="token number">2.</span>Rear指向一个空结点<span class="token punctuation">(</span>程序时更简单<span class="token punctuation">)</span>
    需要注意在最后的时候记得把这个空结点释放掉
    
    处理方法<span class="token number">2</span>的具体代码：
    <span class="token keyword">void</span> <span class="token function">Attach</span> <span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">,</span><span class="token keyword">int</span> e<span class="token punctuation">,</span>Polynomial<span class="token operator">*</span>pRear<span class="token punctuation">)</span><span class="token comment">//Polynomial本身也是指针，所以这里的pRear实际是指针的指针(为什么这么做是因为C语言是函数常数直传递)</span>
<span class="token punctuation">{</span>
    Polynomial P<span class="token punctuation">;</span>
    P <span class="token operator">=</span> <span class="token punctuation">(</span>Polynomial<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">PolyNode</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    P <span class="token operator">-&gt;</span> coef <span class="token operator">=</span> c<span class="token punctuation">;</span><span class="token comment">//对新结点赋值</span>
    P <span class="token operator">-&gt;</span> expon <span class="token operator">=</span> e<span class="token punctuation">;</span>
    P <span class="token operator">-&gt;</span> link <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token punctuation">(</span><span class="token operator">*</span>pRear<span class="token punctuation">)</span><span class="token operator">-&gt;</span>link <span class="token operator">=</span> P<span class="token punctuation">;</span><span class="token comment">//指针指过去了</span>
    <span class="token operator">*</span>pRear <span class="token operator">=</span> P<span class="token punctuation">;</span><span class="token comment">//修改pRear值，指到P那里去了</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/925/image-20220629084605937.png" alt="image-20220629084605937" style="zoom:50%;">

<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/925/image-20220629084915089.png" alt="image-20220629084915089" style="zoom:50%;">

<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/925/image-20220629085051166.png" alt="image-20220629085051166" style="zoom:50%;">

<p><strong>处理方法2</strong></p>
<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/925/image-20220629085848083.png" alt="image-20220629085848083" style="zoom:50%;">

<h4 id="读入多项式的完整程序"><a href="#读入多项式的完整程序" class="headerlink" title="读入多项式的完整程序"></a>读入多项式的完整程序</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c">Polynomial <span class="token function">ReadPoly</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    Polynomial P<span class="token punctuation">,</span>Rear<span class="token punctuation">,</span>t<span class="token punctuation">;</span>
    <span class="token keyword">int</span> c<span class="token punctuation">,</span>e<span class="token punctuation">,</span>N<span class="token punctuation">;</span>
    
    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>N<span class="token punctuation">)</span><span class="token punctuation">;</span>
    P <span class="token operator">=</span> <span class="token punctuation">(</span>Polynomial<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">PolyNode</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//链表头空结点</span>
    P <span class="token operator">-&gt;</span> link <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    Rear <span class="token operator">=</span> P<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>N<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d %d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>c<span class="token punctuation">,</span><span class="token operator">&amp;</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">Attach</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span>e<span class="token punctuation">,</span><span class="token operator">&amp;</span>Rear<span class="token punctuation">)</span><span class="token comment">//将当前项插入多项式尾部</span>
    <span class="token punctuation">}</span>
    t <span class="token operator">=</span> P<span class="token punctuation">;</span>P <span class="token operator">=</span> P <span class="token operator">-&gt;</span> link<span class="token punctuation">;</span><span class="token function">free</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//删除临时生成的头结点  t指向P，P指向P的link  </span>
    <span class="token keyword">return</span> P<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/925/image-20220629091612698.png" alt="image-20220629091612698" style="zoom:50%;">

<h4 id="如何将两个多项式相乘"><a href="#如何将两个多项式相乘" class="headerlink" title="如何将两个多项式相乘"></a>如何将两个多项式相乘</h4><ol>
<li><strong>将当前乘法运算转换为加法运算</strong></li>
</ol>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">将P1当前项<span class="token punctuation">(</span>ci<span class="token punctuation">,</span>ei<span class="token punctuation">)</span>乘P2多项式，再加到结果多项式里
t1 <span class="token operator">=</span> P1<span class="token punctuation">;</span>t2 <span class="token operator">=</span> P2<span class="token punctuation">;</span>
P <span class="token operator">=</span> <span class="token punctuation">(</span>Polynomial<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">PolyNode</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>P<span class="token operator">-&gt;</span>link<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token comment">//指向空结点的操作</span>
Rear <span class="token operator">=</span> P<span class="token punctuation">;</span>
<span class="token keyword">while</span><span class="token punctuation">(</span>t2<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token function">Attach</span><span class="token punctuation">(</span>t1<span class="token operator">-&gt;</span>coef<span class="token operator">*</span>t2<span class="token operator">-&gt;</span>coef<span class="token punctuation">,</span>t1<span class="token operator">-&gt;</span>expon<span class="token operator">+</span>t2<span class="token operator">-&gt;</span>expon<span class="token punctuation">,</span><span class="token operator">&amp;</span>Rear<span class="token punctuation">)</span><span class="token punctuation">;</span>
	t2 <span class="token operator">=</span> t2<span class="token operator">-&gt;</span>link<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>2.逐项插入</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">将P1当前项<span class="token punctuation">(</span>c1i<span class="token punctuation">,</span>e1i<span class="token punctuation">)</span>乘P2当前项<span class="token punctuation">(</span>c2i<span class="token punctuation">,</span>e2i<span class="token punctuation">)</span>，并插入到结果多项式中。关键是要找到插入位置
初始结果多项式可以由P1第一项乘P2获得<span class="token punctuation">(</span>如上<span class="token punctuation">)</span>
    
    具体代码如下
    Polynomial <span class="token function">Mult</span><span class="token punctuation">(</span>Polynomial P1<span class="token punctuation">,</span>Polynomial P2<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    t1 <span class="token operator">=</span> P1；t2 <span class="token operator">=</span> P2<span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">//先用P1的第一项乘以P2,得到P</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
    t1 <span class="token operator">=</span> t1<span class="token operator">-&gt;</span>link<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>t1<span class="token punctuation">)</span><span class="token punctuation">{</span>
        t2 <span class="token operator">=</span> P2<span class="token punctuation">;</span>Rear <span class="token operator">=</span> P<span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>t2<span class="token punctuation">)</span><span class="token punctuation">{</span>
            e<span class="token operator">=</span>t1<span class="token operator">-&gt;</span>expon <span class="token operator">+</span> t2<span class="token operator">-&gt;</span>expon<span class="token punctuation">;</span><span class="token comment">//指数相加</span>
            c<span class="token operator">=</span>t1<span class="token operator">-&gt;</span>coef<span class="token operator">*</span>t2<span class="token operator">-&gt;</span>coef<span class="token punctuation">;</span><span class="token comment">//系数相乘</span>
            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
            t2<span class="token operator">=</span>t2<span class="token operator">-&gt;</span>link<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        t1<span class="token operator">=</span>t1<span class="token operator">-</span><span class="token operator">&lt;</span>link<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>以上代码块中有三项省略号的地方需要解释，单独分别列出来在下方进行标记</p>
<p><strong>第一处省略</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">Polynomial P<span class="token punctuation">,</span>Rear<span class="token punctuation">,</span>t1<span class="token punctuation">,</span>t2<span class="token punctuation">,</span>t<span class="token punctuation">;</span>
<span class="token keyword">int</span> c<span class="token punctuation">,</span>e<span class="token punctuation">;</span>

<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>P1<span class="token operator">||</span><span class="token operator">!</span>P2<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>

t1 <span class="token operator">=</span> P1<span class="token punctuation">;</span>t2 <span class="token operator">=</span> P2<span class="token punctuation">;</span>
P <span class="token operator">=</span> <span class="token punctuation">(</span>Polynomial<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">PolyNode</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>P<span class="token operator">-&gt;</span>link <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
Rear <span class="token operator">=</span> P<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>第二处</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">while</span><span class="token punctuation">(</span>t1<span class="token punctuation">)</span><span class="token punctuation">{</span>
	t2 <span class="token operator">=</span> P2<span class="token punctuation">;</span>Rear <span class="token operator">=</span> P<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>t2<span class="token punctuation">)</span><span class="token punctuation">{</span>
        e <span class="token operator">=</span> t1<span class="token operator">-&gt;</span>expon <span class="token operator">+</span> t2<span class="token operator">-&gt;</span>expon<span class="token punctuation">;</span>
        c <span class="token operator">=</span> t1<span class="token operator">-&gt;</span>coef<span class="token operator">*</span>t2<span class="token operator">-&gt;</span>coef<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>Rear<span class="token operator">-&gt;</span>link <span class="token operator">&amp;&amp;</span> Rear<span class="token operator">-&gt;</span>link<span class="token operator">-&gt;</span>expon<span class="token operator">&gt;</span>e<span class="token punctuation">)</span>
        Rear <span class="token operator">=</span> Rear<span class="token operator">-&gt;</span>link<span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>Rear<span class="token operator">-&gt;</span>link <span class="token operator">&amp;&amp;</span> Rear<span class="token operator">-&gt;</span>link<span class="token operator">-&gt;</span>expon <span class="token operator">==</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>
       <span class="token keyword">if</span><span class="token punctuation">(</span>Rear<span class="token operator">-&gt;</span>link<span class="token operator">-&gt;</span>coef <span class="token operator">+</span> c<span class="token punctuation">)</span><span class="token comment">//判别一下加完是否为0，若不为0则直接加进去，若为0就删掉把内存空间释放</span>
           Rear<span class="token operator">-&gt;</span>link<span class="token operator">-&gt;</span>coef <span class="token operator">+=</span> c<span class="token punctuation">;</span>
        <span class="token keyword">else</span><span class="token punctuation">{</span>
            t <span class="token operator">=</span> Rear <span class="token operator">-&gt;</span> link<span class="token punctuation">;</span>
            Rear<span class="token operator">-&gt;</span>link <span class="token operator">=</span> t <span class="token operator">-&gt;</span>link<span class="token punctuation">;</span>
            <span class="token function">free</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span><span class="token comment">//不相等就是小于的情况，就需要申请一个结点，然后把c跟e赋给这个结点</span>
        t <span class="token operator">=</span> <span class="token punctuation">(</span>Polynomial<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">PolyNode</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        t <span class="token operator">-&gt;</span> coef <span class="token operator">=</span> c<span class="token punctuation">;</span>t<span class="token operator">-&gt;</span>expon <span class="token operator">=</span> e<span class="token punctuation">;</span>
        t <span class="token operator">-&gt;</span>link <span class="token operator">=</span> Rear<span class="token operator">-&gt;</span>link<span class="token punctuation">;</span>
        Rear<span class="token operator">-&gt;</span>link<span class="token operator">=</span>t<span class="token punctuation">;</span>Rear <span class="token operator">=</span> Rear<span class="token operator">-&gt;</span>link<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
        t2 <span class="token operator">=</span> t2<span class="token operator">-&gt;</span>link
    <span class="token punctuation">}</span>
    t1 <span class="token operator">=</span> t1 <span class="token operator">-&gt;</span> link
<span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/925/image-20220629214627763.png" alt="image-20220629214627763"></p>
<p><strong>第三处省略</strong></p>
<pre class="line-numbers language-none"><code class="language-none">t2 = P; P = P-&gt;link;free(t2);
return P;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://GZUCMHjy.github.io">louisBrilliant</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://gzucmhjy.github.io/2022/09/11/shu-ju-jie-gou-di-er-zhou-bi-ji-xian-xing-jie-gou-mu-ke-zhe-da-ban-ben-xiaoyu/">http://gzucmhjy.github.io/2022/09/11/shu-ju-jie-gou-di-er-zhou-bi-ji-xian-xing-jie-gou-mu-ke-zhe-da-ban-ben-xiaoyu/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://GZUCMHjy.github.io" target="_blank">向阳而生_预见未来</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></div><div class="post_share"><div class="social-share" data-image="/./img/landscape_sky3.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2022/08/25/dai-ma-kuai-yan-shi/chang-yong-zheng-ze-biao-da-shi/"><img class="next-cover" src="/./img/landscape_sky3.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">常用的正则表达式集合</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="lv-container" data-id="city" data-uid="MTAyMC81NzAzMS8zMzQ5NQ=="></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fpic1.win4000.com%2Fwallpaper%2F4%2F584688f74cfbc.jpg%3Fdown&amp;refer=http%3A%2F%2Fpic1.win4000.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1662903731&amp;t=d4ee1314a1f8bbd979b30bd14eda9c5c" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">louisBrilliant</div><div class="author-info__description">欢迎大家,进入我的博客世界!</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/GZUCMHjy" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/3506428503@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/blog.juanertu.con" target="_blank" title="博客"><i class="fab fa-algolia"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E5%91%A8%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84-%E6%85%95%E8%AF%BE%E6%B5%99%E5%A4%A7%E7%89%88%E6%9C%AC%E2%80%93XiaoYu"><span class="toc-text">数据结构第二周笔记——线性结构(慕课浙大版本–XiaoYu)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-%E5%BC%95%E5%AD%90%EF%BC%9A%E5%A4%9A%E9%A1%B9%E5%BC%8F%E8%A1%A8%E7%A4%BA"><span class="toc-text">2.1.1 引子：多项式表示</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90%EF%BC%9A%E4%B8%80%E5%85%83%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%8F%8A%E5%85%B6%E8%BF%90%E7%AE%97"><span class="toc-text">例子：一元多项式及其运算</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2-%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%8F%8A%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8"><span class="toc-text">2.1.2 线性表及顺序存储</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E5%AE%9E%E7%8E%B0"><span class="toc-text">线性表的顺序存储实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-3%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%9A%84%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4"><span class="toc-text">2.1.3顺序存储的插入和删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-4-%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E5%8F%8A%E6%9F%A5%E6%89%BE"><span class="toc-text">2.1.4 链式存储及查找</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E5%AE%9E%E7%8E%B0"><span class="toc-text">线性表的链式存储实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-5%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%9A%84%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4"><span class="toc-text">2.1.5链式存储的插入和删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-6-%E5%B9%BF%E4%B9%89%E8%A1%A8%E4%B8%8E%E5%A4%9A%E9%87%8D%E9%93%BE%E8%A1%A8"><span class="toc-text">2.1.6 广义表与多重链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%BF%E4%B9%89%E8%A1%A8-Generalized-List"><span class="toc-text">广义表(Generalized List)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-2-%E5%A0%86%E6%A0%88%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E5%AE%9E%E7%8E%B0"><span class="toc-text">2.2.2 堆栈的顺序存储实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E5%AE%9E%E7%8E%B0"><span class="toc-text">栈的顺序存储实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-3-%E5%A0%86%E6%A0%88%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E5%AE%9E%E7%8E%B0"><span class="toc-text">2.2.3 堆栈的链式存储实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-4-%E5%A0%86%E6%A0%88%E5%BA%94%E7%94%A8%EF%BC%9A%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC"><span class="toc-text">2.2.4 堆栈应用：表达式求值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E5%BF%86%EF%BC%9A%E5%BA%94%E7%94%A8%E5%A0%86%E6%A0%88%E5%AE%9E%E7%8E%B0%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="toc-text">回忆：应用堆栈实现后缀表达式求值的基本过程：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC"><span class="toc-text">中缀表达式求值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E9%98%9F%E5%88%97%E5%8F%8A%E5%AE%9E%E7%8E%B0"><span class="toc-text">2.3 队列及实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%98%9F%E5%88%97"><span class="toc-text">什么是队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1-%E9%98%9F%E5%88%97%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E5%AE%9E%E7%8E%B0"><span class="toc-text">2.3.1 队列的顺序存储实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%BA%E7%8E%AF%E9%98%9F%E5%88%97"><span class="toc-text">顺环队列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-2-%E9%98%9F%E5%88%97%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E5%AE%9E%E7%8E%B0"><span class="toc-text">2.3.2 队列的链式存储实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E5%8A%A0%E6%B3%95%E8%BF%90%E7%AE%97%E5%AE%9E%E7%8E%B0"><span class="toc-text">2.4 多项式的加法运算实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%99%BD%E4%B8%93%E5%9C%BA"><span class="toc-text">小白专场</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="toc-text">多项式的表示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA"><span class="toc-text">程序框架搭建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%85%A5%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E5%AE%8C%E6%95%B4%E7%A8%8B%E5%BA%8F"><span class="toc-text">读入多项式的完整程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%B0%86%E4%B8%A4%E4%B8%AA%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9B%B8%E4%B9%98"><span class="toc-text">如何将两个多项式相乘</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/09/11/shu-ju-jie-gou-di-er-zhou-bi-ji-xian-xing-jie-gou-mu-ke-zhe-da-ban-ben-xiaoyu/" title="数据结构笔记(一)"><img src="/./img/landscape_sky3.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据结构笔记(一)"/></a><div class="content"><a class="title" href="/2022/09/11/shu-ju-jie-gou-di-er-zhou-bi-ji-xian-xing-jie-gou-mu-ke-zhe-da-ban-ben-xiaoyu/" title="数据结构笔记(一)">数据结构笔记(一)</a><time datetime="2022-09-11T15:30:34.026Z" title="发表于 2022-09-11 23:30:34">2022-09-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/25/dai-ma-kuai-yan-shi/chang-yong-zheng-ze-biao-da-shi/" title="常用的正则表达式集合"><img src="/./img/landscape_sky3.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="常用的正则表达式集合"/></a><div class="content"><a class="title" href="/2022/08/25/dai-ma-kuai-yan-shi/chang-yong-zheng-ze-biao-da-shi/" title="常用的正则表达式集合">常用的正则表达式集合</a><time datetime="2022-08-25T08:41:24.000Z" title="发表于 2022-08-25 16:41:24">2022-08-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/18/javaweb-xue-xi-bi-ji/" title="javaweb学习笔记"><img src="/./img/landscape_sky3.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="javaweb学习笔记"/></a><div class="content"><a class="title" href="/2022/08/18/javaweb-xue-xi-bi-ji/" title="javaweb学习笔记">javaweb学习笔记</a><time datetime="2022-08-17T22:41:24.000Z" title="发表于 2022-08-18 06:41:24">2022-08-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/18/biao-dan-zhi-zuo/" title="表单制作"><img src="/./img/landscape_sky3.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="表单制作"/></a><div class="content"><a class="title" href="/2022/08/18/biao-dan-zhi-zuo/" title="表单制作">表单制作</a><time datetime="2022-08-17T22:41:24.000Z" title="发表于 2022-08-18 06:41:24">2022-08-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/17/suan-fa-bi-ji-yi/" title="算法笔记一"><img src="/./img/landscape_sky3.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="算法笔记一"/></a><div class="content"><a class="title" href="/2022/08/17/suan-fa-bi-ji-yi/" title="算法笔记一">算法笔记一</a><time datetime="2022-08-17T07:07:41.192Z" title="发表于 2022-08-17 15:07:41">2022-08-17</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 By louisBrilliant</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener" href="https://butterfly.js.org/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function loadLivere () {
  if (typeof LivereTower === 'object') {
    window.LivereTower.init()
  }
  else {
    (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
    })(document, 'script');
  }
}

if ('Livere' === 'Livere' || !false) {
  if (false) btf.loadComment(document.getElementById('lv-container'), loadLivere)
  else loadLivere()
}
else {
  function loadOtherComment () {
    loadLivere()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>